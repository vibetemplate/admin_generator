# 开发最佳实践

本文档总结了使用后台管理系统生成器的最佳实践，帮助开发者构建高质量、可维护的管理后台系统。

## 🏗️ 架构设计

### 1. 目录结构

```
my-admin/
├── app/                     # Next.js App Router
│   ├── (auth)/             # 认证路由组
│   │   ├── login/
│   │   └── register/
│   ├── (dashboard)/        # 主要功能路由组
│   │   ├── dashboard/
│   │   ├── users/
│   │   └── products/
│   ├── api/                # API 路由
│   ├── globals.css
│   └── layout.tsx
├── components/             # 组件库
│   ├── ui/                # 基础UI组件
│   ├── business/          # 业务组件
│   └── layout/            # 布局组件
├── lib/                   # 工具库
│   ├── api.ts            # API客户端
│   ├── auth.ts           # 认证工具
│   ├── utils.ts          # 通用工具
│   └── validations.ts    # 表单验证
├── hooks/                # 自定义Hooks
├── store/                # 状态管理
├── types/                # TypeScript类型定义
├── constants/            # 常量定义
└── config/               # 配置文件
```

### 2. 模块化设计

```typescript
// types/user.ts
export interface User {
  id: string
  name: string
  email: string
  role: UserRole
}

// hooks/useUsers.ts
export const useUsers = () => {
  return useQuery({
    queryKey: ['users'],
    queryFn: fetchUsers
  })
}

// components/business/UserList.tsx
export const UserList = () => {
  const { data: users, loading } = useUsers()
  
  return (
    <DataTable
      columns={userColumns}
      data={users}
      loading={loading}
    />
  )
}
```

### 3. 分层架构

```
┌─────────────────┐
│   Presentation  │ ← 页面组件 (app/*)
├─────────────────┤
│   Business      │ ← 业务组件 (components/business/*)
├─────────────────┤
│   UI            │ ← UI组件 (components/ui/*)
├─────────────────┤
│   Service       │ ← API服务 (lib/api.ts)
├─────────────────┤
│   Data          │ ← 状态管理 (store/*)
└─────────────────┘
```

## 🎨 组件设计

### 1. 组件复用原则

```typescript
// ❌ 不好的做法 - 组件耦合度高
const UserManagement = () => {
  return (
    <div>
      <div className="header">用户管理</div>
      <div className="search">
        <Input placeholder="搜索用户" />
        <Button>搜索</Button>
      </div>
      <Table columns={userColumns} data={users} />
    </div>
  )
}

// ✅ 好的做法 - 组件可复用
const UserManagement = () => {
  return (
    <PageContainer title="用户管理">
      <SearchForm fields={userSearchFields} onSearch={handleSearch} />
      <DataTable columns={userColumns} data={users} actions={userActions} />
    </PageContainer>
  )
}
```

### 2. 组件属性设计

```typescript
// ✅ 清晰的属性接口
interface DataTableProps<T = any> {
  columns: DataTableColumn<T>[]
  data: T[]
  loading?: boolean
  pagination?: PaginationConfig
  rowSelection?: RowSelectionConfig
  actions?: ActionConfig[]
  onRefresh?: () => void
  onCreate?: () => void
}

// ✅ 默认值处理
const DataTable = <T,>({
  columns,
  data,
  loading = false,
  pagination = defaultPagination,
  actions = [],
  ...props
}: DataTableProps<T>) => {
  // 组件实现
}
```

### 3. 组件组合模式

```typescript
// ✅ 使用组合模式提高灵活性
const UserPage = () => {
  return (
    <PageContainer title="用户管理">
      <SearchForm fields={searchFields} onSearch={handleSearch} />
      
      <Card>
        <DataTable.Toolbar>
          <DataTable.Actions>
            <Button type="primary" onClick={handleCreate}>
              新建用户
            </Button>
          </DataTable.Actions>
          <DataTable.Filters>
            <Select placeholder="角色筛选" options={roleOptions} />
          </DataTable.Filters>
        </DataTable.Toolbar>
        
        <DataTable
          columns={columns}
          data={data}
          loading={loading}
        />
      </Card>
    </PageContainer>
  )
}
```

## 🔄 状态管理

### 1. 数据获取模式

```typescript
// 使用 React Query 管理服务端状态
export const useUsers = (params?: UserSearchParams) => {
  return useQuery({
    queryKey: ['users', params],
    queryFn: () => fetchUsers(params),
    staleTime: 5 * 60 * 1000, // 5分钟
    cacheTime: 10 * 60 * 1000, // 10分钟
  })
}

// 使用 Zustand 管理客户端状态
interface AppState {
  user: User | null
  theme: Theme
  sidebarCollapsed: boolean
}

export const useAppStore = create<AppState>((set) => ({
  user: null,
  theme: 'light',
  sidebarCollapsed: false,
  setUser: (user) => set({ user }),
  toggleSidebar: () => set((state) => ({ 
    sidebarCollapsed: !state.sidebarCollapsed 
  })),
}))
```

### 2. 表单状态管理

```typescript
// 使用 React Hook Form + Zod
const userSchema = z.object({
  name: z.string().min(2, '姓名至少2个字符'),
  email: z.string().email('请输入有效的邮箱地址'),
  role: z.enum(['admin', 'user'], {
    required_error: '请选择角色'
  })
})

type UserFormData = z.infer<typeof userSchema>

const UserForm = () => {
  const form = useForm<UserFormData>({
    resolver: zodResolver(userSchema),
    defaultValues: {
      name: '',
      email: '',
      role: 'user'
    }
  })

  const onSubmit = (data: UserFormData) => {
    // 提交处理
  }

  return (
    <Form {...form}>
      <form onSubmit={form.handleSubmit(onSubmit)}>
        {/* 表单字段 */}
      </form>
    </Form>
  )
}
```

## 🔐 权限管理

### 1. 权限检查Hooks

```typescript
// hooks/usePermissions.ts
export const usePermissions = () => {
  const { user } = useAuth()
  
  const hasPermission = useCallback((permission: string) => {
    if (!user || !user.permissions) return false
    
    // 超级管理员拥有所有权限
    if (user.permissions.includes('*')) return true
    
    // 检查具体权限
    return user.permissions.includes(permission)
  }, [user])
  
  const hasAnyPermission = useCallback((permissions: string[]) => {
    return permissions.some(permission => hasPermission(permission))
  }, [hasPermission])
  
  return { hasPermission, hasAnyPermission }
}
```

### 2. 权限保护组件

```typescript
// components/auth/PermissionGuard.tsx
interface PermissionGuardProps {
  permission: string | string[]
  fallback?: React.ReactNode
  children: React.ReactNode
}

export const PermissionGuard: React.FC<PermissionGuardProps> = ({
  permission,
  fallback = null,
  children
}) => {
  const { hasPermission, hasAnyPermission } = usePermissions()
  
  const allowed = Array.isArray(permission)
    ? hasAnyPermission(permission)
    : hasPermission(permission)
  
  return allowed ? children : fallback
}

// 使用示例
<PermissionGuard permission="users:create">
  <Button type="primary" onClick={handleCreate}>
    新建用户
  </Button>
</PermissionGuard>
```

### 3. 路由权限保护

```typescript
// middleware.ts
export function middleware(request: NextRequest) {
  const token = request.cookies.get('token')?.value
  
  if (!token) {
    return NextResponse.redirect(new URL('/login', request.url))
  }
  
  // 验证token并检查路由权限
  const user = verifyToken(token)
  const pathname = request.nextUrl.pathname
  
  if (!hasRoutePermission(user, pathname)) {
    return NextResponse.redirect(new URL('/403', request.url))
  }
  
  return NextResponse.next()
}

export const config = {
  matcher: [
    '/((?!api|_next/static|_next/image|favicon.ico|login).*)',
  ],
}
```

## 📊 数据处理

### 1. API客户端封装

```typescript
// lib/api.ts
class ApiClient {
  private baseURL: string
  private timeout: number

  constructor(config: ApiConfig) {
    this.baseURL = config.baseURL
    this.timeout = config.timeout
  }

  private async request<T>(
    url: string,
    options: RequestInit = {}
  ): Promise<ApiResponse<T>> {
    const controller = new AbortController()
    const timeoutId = setTimeout(() => controller.abort(), this.timeout)

    try {
      const response = await fetch(`${this.baseURL}${url}`, {
        ...options,
        signal: controller.signal,
        headers: {
          'Content-Type': 'application/json',
          ...this.getAuthHeaders(),
          ...options.headers,
        },
      })

      clearTimeout(timeoutId)

      if (!response.ok) {
        throw new ApiError(response.status, await response.text())
      }

      return await response.json()
    } catch (error) {
      clearTimeout(timeoutId)
      throw error
    }
  }

  async get<T>(url: string): Promise<ApiResponse<T>> {
    return this.request<T>(url, { method: 'GET' })
  }

  async post<T>(url: string, data?: any): Promise<ApiResponse<T>> {
    return this.request<T>(url, {
      method: 'POST',
      body: data ? JSON.stringify(data) : undefined,
    })
  }
}

export const apiClient = new ApiClient({
  baseURL: process.env.NEXT_PUBLIC_API_URL!,
  timeout: 10000,
})
```

### 2. 错误处理

```typescript
// lib/error-handler.ts
export class AppError extends Error {
  constructor(
    public code: string,
    public message: string,
    public statusCode?: number
  ) {
    super(message)
    this.name = 'AppError'
  }
}

export const errorHandler = (error: unknown) => {
  console.error('应用错误:', error)

  if (error instanceof AppError) {
    message.error(error.message)
  } else if (error instanceof ApiError) {
    switch (error.statusCode) {
      case 401:
        message.error('登录已过期，请重新登录')
        // 跳转到登录页
        break
      case 403:
        message.error('权限不足')
        break
      case 500:
        message.error('服务器错误，请稍后重试')
        break
      default:
        message.error('操作失败，请重试')
    }
  } else {
    message.error('未知错误，请联系管理员')
  }
}

// 全局错误处理
export const setupGlobalErrorHandler = () => {
  window.addEventListener('unhandledrejection', (event) => {
    errorHandler(event.reason)
    event.preventDefault()
  })

  window.addEventListener('error', (event) => {
    errorHandler(event.error)
  })
}
```

### 3. 数据验证

```typescript
// lib/validations.ts
export const commonValidations = {
  required: (message?: string) => ({
    required: true,
    message: message || '此字段为必填项'
  }),

  email: (message?: string) => ({
    type: 'email' as const,
    message: message || '请输入有效的邮箱地址'
  }),

  phone: (message?: string) => ({
    pattern: /^1[3-9]\d{9}$/,
    message: message || '请输入有效的手机号码'
  }),

  minLength: (min: number, message?: string) => ({
    min,
    message: message || `最少输入${min}个字符`
  }),

  maxLength: (max: number, message?: string) => ({
    max,
    message: message || `最多输入${max}个字符`
  })
}

// 使用示例
const userFormFields: FormField[] = [
  {
    name: 'name',
    label: '姓名',
    type: 'input',
    rules: [
      commonValidations.required(),
      commonValidations.minLength(2)
    ]
  },
  {
    name: 'email',
    label: '邮箱',
    type: 'input',
    rules: [
      commonValidations.required(),
      commonValidations.email()
    ]
  }
]
```

## 🎯 性能优化

### 1. 组件懒加载

```typescript
// 路由级别懒加载
const UserManagement = lazy(() => import('./pages/UserManagement'))
const ProductManagement = lazy(() => import('./pages/ProductManagement'))

const AppRouter = () => {
  return (
    <Suspense fallback={<Loading />}>
      <Routes>
        <Route path="/users" element={<UserManagement />} />
        <Route path="/products" element={<ProductManagement />} />
      </Routes>
    </Suspense>
  )
}

// 组件级别懒加载
const DataTable = lazy(() => import('./components/DataTable'))

const ListPage = () => {
  return (
    <Suspense fallback={<Skeleton />}>
      <DataTable columns={columns} data={data} />
    </Suspense>
  )
}
```

### 2. 虚拟滚动

```typescript
// 大数据量表格使用虚拟滚动
import { FixedSizeList as List } from 'react-window'

const VirtualTable = ({ data, columns, height = 400 }) => {
  const Row = ({ index, style }) => (
    <div style={style} className="table-row">
      {columns.map(col => (
        <div key={col.key} className="table-cell">
          {data[index][col.dataIndex]}
        </div>
      ))}
    </div>
  )

  return (
    <List
      height={height}
      itemCount={data.length}
      itemSize={50}
      width="100%"
    >
      {Row}
    </List>
  )
}
```

### 3. 缓存策略

```typescript
// React Query 缓存配置
const queryClient = new QueryClient({
  defaultOptions: {
    queries: {
      staleTime: 5 * 60 * 1000, // 5分钟内不重新获取
      cacheTime: 10 * 60 * 1000, // 缓存10分钟
      retry: (failureCount, error) => {
        // 4xx错误不重试
        if (error instanceof ApiError && error.statusCode < 500) {
          return false
        }
        return failureCount < 3
      },
      refetchOnWindowFocus: false,
    },
  },
})

// 预取数据
const prefetchUserDetails = (userId: string) => {
  queryClient.prefetchQuery({
    queryKey: ['user', userId],
    queryFn: () => fetchUser(userId),
  })
}
```

## 🧪 测试策略

### 1. 单元测试

```typescript
// __tests__/components/DataTable.test.tsx
import { render, screen, fireEvent } from '@testing-library/react'
import { DataTable } from '../components/DataTable'

const mockData = [
  { id: '1', name: '张三', email: 'zhangsan@example.com' }
]

const mockColumns = [
  { title: '姓名', dataIndex: 'name', key: 'name' },
  { title: '邮箱', dataIndex: 'email', key: 'email' }
]

describe('DataTable', () => {
  it('应该渲染数据', () => {
    render(
      <DataTable 
        columns={mockColumns} 
        data={mockData} 
      />
    )
    
    expect(screen.getByText('张三')).toBeInTheDocument()
    expect(screen.getByText('zhangsan@example.com')).toBeInTheDocument()
  })

  it('应该处理搜索', () => {
    const onSearch = jest.fn()
    
    render(
      <DataTable 
        columns={mockColumns} 
        data={mockData}
        onSearch={onSearch}
      />
    )
    
    const searchInput = screen.getByPlaceholderText('搜索...')
    fireEvent.change(searchInput, { target: { value: '张三' } })
    fireEvent.click(screen.getByText('搜索'))
    
    expect(onSearch).toHaveBeenCalledWith('张三')
  })
})
```

### 2. 集成测试

```typescript
// __tests__/pages/UserManagement.test.tsx
import { render, screen, waitFor } from '@testing-library/react'
import { QueryClient, QueryClientProvider } from '@tanstack/react-query'
import { UserManagement } from '../pages/UserManagement'

const createTestQueryClient = () =>
  new QueryClient({
    defaultOptions: {
      queries: { retry: false },
      mutations: { retry: false },
    },
  })

const renderWithProviders = (component: React.ReactElement) => {
  const queryClient = createTestQueryClient()
  return render(
    <QueryClientProvider client={queryClient}>
      {component}
    </QueryClientProvider>
  )
}

describe('UserManagement', () => {
  it('应该加载并显示用户列表', async () => {
    renderWithProviders(<UserManagement />)
    
    expect(screen.getByText('加载中...')).toBeInTheDocument()
    
    await waitFor(() => {
      expect(screen.getByText('用户管理')).toBeInTheDocument()
      expect(screen.getByText('张三')).toBeInTheDocument()
    })
  })
})
```

### 3. E2E测试

```typescript
// e2e/user-management.spec.ts
import { test, expect } from '@playwright/test'

test.describe('用户管理', () => {
  test.beforeEach(async ({ page }) => {
    await page.goto('/login')
    await page.fill('[data-testid=email]', 'admin@example.com')
    await page.fill('[data-testid=password]', 'password123')
    await page.click('[data-testid=login-button]')
    await page.goto('/users')
  })

  test('应该能够创建新用户', async ({ page }) => {
    await page.click('[data-testid=create-user-button]')
    
    await page.fill('[data-testid=user-name]', '测试用户')
    await page.fill('[data-testid=user-email]', 'test@example.com')
    await page.selectOption('[data-testid=user-role]', 'user')
    
    await page.click('[data-testid=submit-button]')
    
    await expect(page.locator('.ant-message-success')).toBeVisible()
    await expect(page.locator('text=测试用户')).toBeVisible()
  })
})
```

## 📱 响应式设计

### 1. 断点管理

```typescript
// hooks/useBreakpoint.ts
export const useBreakpoint = () => {
  const [breakpoint, setBreakpoint] = useState<string>('lg')

  useEffect(() => {
    const updateBreakpoint = () => {
      const width = window.innerWidth
      if (width < 480) setBreakpoint('xs')
      else if (width < 576) setBreakpoint('sm')
      else if (width < 768) setBreakpoint('md')
      else if (width < 992) setBreakpoint('lg')
      else if (width < 1200) setBreakpoint('xl')
      else setBreakpoint('xxl')
    }

    updateBreakpoint()
    window.addEventListener('resize', updateBreakpoint)
    return () => window.removeEventListener('resize', updateBreakpoint)
  }, [])

  const isMobile = breakpoint === 'xs' || breakpoint === 'sm'
  const isTablet = breakpoint === 'md'
  const isDesktop = breakpoint === 'lg' || breakpoint === 'xl' || breakpoint === 'xxl'

  return { breakpoint, isMobile, isTablet, isDesktop }
}
```

### 2. 响应式布局

```typescript
// components/ResponsiveLayout.tsx
const ResponsiveLayout = ({ children }) => {
  const { isMobile, isTablet } = useBreakpoint()

  return (
    <Layout className={cn(
      'min-h-screen',
      isMobile && 'mobile-layout',
      isTablet && 'tablet-layout'
    )}>
      <Sider 
        collapsible
        collapsed={isMobile}
        trigger={null}
        width={isMobile ? 0 : 256}
        collapsedWidth={isMobile ? 0 : 80}
      >
        <SideMenu />
      </Sider>
      
      <Layout>
        <Header className="flex items-center justify-between">
          {isMobile && <MobileMenuButton />}
          <div className="flex-1" />
          <UserDropdown />
        </Header>
        
        <Content className={cn(
          'p-6',
          isMobile && 'p-4'
        )}>
          {children}
        </Content>
      </Layout>
    </Layout>
  )
}
```

## 🔒 安全最佳实践

### 1. 输入验证

```typescript
// lib/sanitize.ts
import DOMPurify from 'dompurify'

export const sanitizeInput = (input: string): string => {
  return DOMPurify.sanitize(input.trim())
}

export const validateInput = (input: string, rules: ValidationRule[]): string[] => {
  const errors: string[] = []
  
  for (const rule of rules) {
    if (!rule.validator(input)) {
      errors.push(rule.message)
    }
  }
  
  return errors
}

// 使用示例
const handleSubmit = (data: FormData) => {
  const sanitizedData = {
    name: sanitizeInput(data.name),
    description: sanitizeInput(data.description)
  }
  
  // 提交处理
}
```

### 2. XSS防护

```typescript
// components/SafeHTML.tsx
interface SafeHTMLProps {
  html: string
  className?: string
}

export const SafeHTML: React.FC<SafeHTMLProps> = ({ html, className }) => {
  const sanitizedHTML = useMemo(() => {
    return DOMPurify.sanitize(html, {
      ALLOWED_TAGS: ['p', 'br', 'strong', 'em', 'u', 'a'],
      ALLOWED_ATTR: ['href', 'target'],
    })
  }, [html])

  return (
    <div 
      className={className}
      dangerouslySetInnerHTML={{ __html: sanitizedHTML }}
    />
  )
}
```

### 3. CSRF防护

```typescript
// lib/csrf.ts
export const getCSRFToken = (): string => {
  const meta = document.querySelector('meta[name="csrf-token"]')
  return meta?.getAttribute('content') || ''
}

export const apiClientWithCSRF = axios.create({
  baseURL: '/api',
  headers: {
    'X-CSRF-Token': getCSRFToken(),
  },
})
```

## 📈 监控和分析

### 1. 错误监控

```typescript
// lib/monitoring.ts
import * as Sentry from '@sentry/nextjs'

export const initMonitoring = () => {
  Sentry.init({
    dsn: process.env.NEXT_PUBLIC_SENTRY_DSN,
    environment: process.env.NODE_ENV,
    tracesSampleRate: 1.0,
  })
}

export const trackError = (error: Error, context?: Record<string, any>) => {
  Sentry.captureException(error, {
    contexts: { custom: context },
  })
}

export const trackEvent = (eventName: string, properties?: Record<string, any>) => {
  Sentry.addBreadcrumb({
    message: eventName,
    data: properties,
    level: 'info',
  })
}
```

### 2. 性能监控

```typescript
// lib/performance.ts
export const measurePerformance = (name: string, fn: () => void) => {
  const start = performance.now()
  fn()
  const end = performance.now()
  
  console.log(`${name} 执行时间: ${end - start}ms`)
  
  // 上报性能数据
  if (end - start > 1000) {
    trackEvent('slow_operation', {
      operation: name,
      duration: end - start,
    })
  }
}

export const usePerformanceMonitor = (componentName: string) => {
  useEffect(() => {
    const startTime = performance.now()
    
    return () => {
      const endTime = performance.now()
      const renderTime = endTime - startTime
      
      if (renderTime > 500) {
        trackEvent('slow_render', {
          component: componentName,
          renderTime,
        })
      }
    }
  }, [componentName])
}
```

## 📚 文档化

### 1. 代码注释

```typescript
/**
 * 数据表格组件
 * 
 * @example
 * ```tsx
 * <DataTable
 *   columns={columns}
 *   data={data}
 *   loading={loading}
 *   onRefresh={() => refetch()}
 * />
 * ```
 */
export interface DataTableProps<T = any> {
  /** 表格列配置 */
  columns: DataTableColumn<T>[]
  /** 表格数据 */
  data: T[]
  /** 加载状态 */
  loading?: boolean
  /** 刷新回调 */
  onRefresh?: () => void
}
```

### 2. README文档

```markdown
# 用户管理模块

## 功能说明

用户管理模块提供完整的用户CRUD操作，包括：

- 用户列表查看
- 用户创建和编辑
- 用户权限管理
- 用户状态控制

## 使用方法

### 基础用法

```tsx
import { UserManagement } from '@/components/business'

export default function UsersPage() {
  return <UserManagement />
}
```

### 自定义配置

```tsx
<UserManagement
  searchable={true}
  exportable={true}
  batchOperations={true}
/>
```

## API接口

- `GET /api/users` - 获取用户列表
- `POST /api/users` - 创建用户
- `PUT /api/users/:id` - 更新用户
- `DELETE /api/users/:id` - 删除用户

## 权限要求

- `users:view` - 查看用户列表
- `users:create` - 创建用户
- `users:edit` - 编辑用户
- `users:delete` - 删除用户
```

这些最佳实践将帮助你构建高质量、可维护、安全的后台管理系统。记住，好的代码不仅仅是能运行，更重要的是易于理解、测试和维护。